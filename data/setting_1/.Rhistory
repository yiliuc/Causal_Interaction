# install.packages("janitor")
library(tidyverse)
#### Workspace setup ####
install.packages("tidyverse")
install.packages("janitor")
library(tidyverse)
library(janitor)
#### Workspace setup ####
install.packages("tidyverse")
#### Workspace setup ####
install.packages("tidyverse")
library(tidyverse)
setwd("/Users/caoyiliu/Desktop/UW/research/7.9/0_original")
setwd("/Users/caoyiliu/Desktop/UW/research/7.9/1_weak_confounding")
simulate_data_intercept <- function(n, beta0, seed = NULL) {
if (!is.null(seed)) set.seed(seed)
## ------------------------------------------------------------------
## 1. Generate covariates  X1 … X8   ~  N(0,1), mutually independent
## ------------------------------------------------------------------
X <- matrix(rnorm(n * 8), ncol = 8,
dimnames = list(NULL, paste0("X", 1:8)))
X1 <- X[, 1];  X2 <- X[, 2]        #   X_G  (instrumental for G)
X3 <- X[, 3];  X4 <- X[, 4]        #   X_E  (instrumental for E)
X5 <- X[, 5];  X6 <- X[, 6]        #   X_Y  (outcome-only)
X7 <- X[, 7];  X8 <- X[, 8]        #   C    (common confounders)
## ------------------------------------------------------------------
## 2. Propensity scores for each treatment, given its instruments + C
## ------------------------------------------------------------------
eta_G <-  0.8 * X1 + 0.5 * X2 - 0.3 * X7 + 0.5 * X8      # f(Z_G)
pi_G  <- plogis(eta_G)
eta_E <- -0.5 * X3 + 0.2 * X4 + 0.3 * X7 + 0.5 * X8      # f(Z_E)
pi_E  <- plogis(eta_E)
## ------------------------------------------------------------------
## 3. Joint treatment assignment  (G,E)  ~ Multinomial(1, θ00, θ10, θ01, θ11)
## ------------------------------------------------------------------
p00 <- (1 - pi_G) * (1 - pi_E)
p10 <-  pi_G      * (1 - pi_E)
p01 <- (1 - pi_G) *  pi_E
p11 <-  pi_G      *  pi_E
probs <- cbind(p00, p10, p01, p11)
draw <- apply(probs, 1, function(p) {
sample(1:4, size = 1, prob = p)
})
G <- as.integer(draw %in% c(2, 4))   # (1,0) or (1,1)
E <- as.integer(draw %in% c(3, 4))   # (0,1) or (1,1)
## ------------------------------------------------------------------
## 4. Outcome model  Pr(Y = 1 | Z_Y, G, E)
## ------------------------------------------------------------------
eta_Y <- beta0 +
0.3 * X5  + 0.5 * X6  - 0.2 * X7 - 0.1 * X8 +   # outcome-only + C
0.3 * G   + 0.4 * E  + 0.8 * (G * E)            # treatments & interaction
pi_Y <- plogis(eta_Y)
Y    <- rbinom(n, size = 1, prob = pi_Y)
## ------------------------------------------------------------------
## 5. Return tidy data frame
## ------------------------------------------------------------------
return(data.frame(Y, G, E, X))
}
############################################################
# 1. Compute the weight w = 1/p(G|C)·1/p(E|G,C)=1/(p(G,E|C))
compute_ipw <- function(dat,
covars,
use = "control",
eps          = 1e-6,
truncate_q   = NULL) {
stopifnot(all(c("Y", "G", "E", covars) %in% names(dat)))
# Choose the data to fit the model
used_data <- if (use == "control"){
dat[dat$Y == 0, ]
} else if (use == "both") {
dat <- dat
}
# P(G = 1 | C)
f_G   <- reformulate(covars, response = "G")
mod_G <- glm(f_G, data = used_data, family = binomial())
# P(E = 1 | G, C)
f_E   <- reformulate(c("G", covars), response = "E")
mod_E <- glm(f_E, data = used_data, family = binomial())
pG1 <- predict(mod_G, newdata = dat, type = "response")
pE1 <- predict(mod_E, newdata = dat, type = "response")
# pG1 <- pmin(pmax(pG1, eps), 1 - eps)
# pE1 <- pmin(pmax(pE1, eps), 1 - eps)
# P(G = g_i | C)
pG  <- ifelse(dat$G == 1, pG1, 1 - pG1)
## P(E = e_i | G, C)
pE  <- ifelse(dat$E == 1, pE1, 1 - pE1)
w   <- 1 / (pG * pE)
if (!is.null(truncate_q)) {
q_hi <- quantile(w, truncate_q, na.rm = TRUE)
q_lo <- quantile(w, 1 - truncate_q, na.rm = TRUE)
w    <- pmin(pmax(w, q_lo), q_hi)
}
dat$w <- w
dat
}
sim_dat <- simulate_data_intercept(3000, -1, 2025)
covars_G =  c("X1", "X2", "X5", "X6")
covars_E =  c("X3", "X4", "X5", "X6")
w <- compute_ipw(sim_dat, covars_G = covars_G, covars_E = covars_E, use = "control")
############################################################
# 1. Compute the weight w = 1/p(G|C)·1/p(E|G,C)=1/(p(G,E|C))
compute_ipw <- function(dat,
covars_G = paste0("X", 1:6),
covars_E = paste0("X", 1:6),
use = "control",
eps          = 1e-6,
truncate_q   = NULL) {
stopifnot(all(c("Y", "G", "E", covars_G, covars_E) %in% names(dat)))
# Choose the data to fit the model
used_data <- if (use == "control"){
dat[dat$Y == 0, ]
} else if (use == "both") {
dat <- dat
}
# P(G = 1 | C)
f_G   <- reformulate(covars_G, response = "G")
mod_G <- glm(f_G, data = used_data, family = binomial())
# P(E = 1 | G, C)
f_E   <- reformulate(c("G", covars_E), response = "E")
mod_E <- glm(f_E, data = used_data, family = binomial())
pG1 <- predict(mod_G, newdata = dat, type = "response")
pE1 <- predict(mod_E, newdata = dat, type = "response")
# pG1 <- pmin(pmax(pG1, eps), 1 - eps)
# pE1 <- pmin(pmax(pE1, eps), 1 - eps)
# P(G = g_i | C)
pG  <- ifelse(dat$G == 1, pG1, 1 - pG1)
## P(E = e_i | G, C)
pE  <- ifelse(dat$E == 1, pE1, 1 - pE1)
w   <- 1 / (pG * pE)
if (!is.null(truncate_q)) {
q_hi <- quantile(w, truncate_q, na.rm = TRUE)
q_lo <- quantile(w, 1 - truncate_q, na.rm = TRUE)
w    <- pmin(pmax(w, q_lo), q_hi)
}
dat$w <- w
dat
}
sim_dat <- simulate_data_intercept(3000, -1, 2025)
covars_G =  c("X5", "X6", "X7", "X8")
covars_E =  c("X5", "X6", "X7", "X8")
w <- compute_ipw(sim_dat, covars_G = covars_G, covars_E = covars_E, use = "control")
w[w$w > 20,]
sim_dat <- simulate_data_intercept(3000, -6, 2025)
covars_G =  c("X5", "X6", "X7", "X8")
covars_E =  c("X5", "X6", "X7", "X8")
w2 <- compute_ipw(sim_dat, covars_G = covars_G, covars_E = covars_E, use = "control")
w2[w2$w > 20,]
sim_dat <- simulate_data_intercept(3000, -2, 2025)
covars_G =  c("X5", "X6", "X7", "X8")
covars_E =  c("X5", "X6", "X7", "X8")
w3 <- compute_ipw(sim_dat, covars_G = covars_G, covars_E = covars_E, use = "control")
w3[w3$w > 20,]
################################################################################
simulate_data_intercept <- function(n, beta0, seed = NULL) {
if (!is.null(seed)) set.seed(seed)
# Covariates
X <- matrix(rnorm(n * 6), ncol = 6,
dimnames = list(NULL, paste0("X", 1:6)))
X1 <- X[, 1]; X2 <- X[, 2]; X3 <- X[, 3]
X4 <- X[, 4]; X5 <- X[, 5]; X6 <- X[, 6]
# marginal propensities
eta_G <-  0.8*X1 + 0.5*X2 - 0.3*X5 + 0.4*X6
pi_G  <- plogis(eta_G)
eta_E <- -0.5*X3 + 0.2*X4 + 0.3*X5 + 0.6*X6
pi_E  <- plogis(eta_E)
# joint probabilities & multinomial draw
p00 <- (1 - pi_G) * (1 - pi_E)
p10 <-  pi_G      * (1 - pi_E)
p01 <- (1 - pi_G) *  pi_E
p11 <-  pi_G      *  pi_E
probs <- cbind(p00, p10, p01, p11)
draw <- apply(probs, 1, function(p) {
sample(1:4, size = 1, prob = p)
})
G <- as.integer(draw %in% c(2, 4))  # (1,0) and (1,1)
E <- as.integer(draw %in% c(3, 4))  # (0,1) and (1,1)
# Outcome
eta_Y <- beta0 +
# 0.3*X1 - 0.5*X2 + 0.7*X3 + 0.9*X4 - 0.2*X5 + 0.3*X6 +
0.3*X1 - 0.5*X2 + 0.7*X3 + 0.9*X4 - 0.2*X5 + 0.3*X6 +
# 0.3*G + 0.4*E + 0.8*(G*E)
0.3*G + 0.4*E + 0.8*(G*E)
pi_Y <- plogis(eta_Y)
Y    <- rbinom(n, 1, pi_Y)
return(data.frame(Y, G, E, X))
}
############################################################
# 1. Compute the weight w = 1/p(G|C)·1/p(E|G,C)=1/(p(G,E|C))
compute_ipw <- function(dat,
covars_G = paste0("X", 1:6),
covars_E = paste0("X", 1:6),
use = "control",
eps          = 1e-6,
truncate_q   = NULL) {
stopifnot(all(c("Y", "G", "E", covars_G, covars_E) %in% names(dat)))
# Choose the data to fit the model
used_data <- if (use == "control"){
dat[dat$Y == 0, ]
} else if (use == "both") {
dat <- dat
}
# P(G = 1 | C)
f_G   <- reformulate(covars_G, response = "G")
mod_G <- glm(f_G, data = used_data, family = binomial())
# P(E = 1 | G, C)
f_E   <- reformulate(c("G", covars_E), response = "E")
mod_E <- glm(f_E, data = used_data, family = binomial())
pG1 <- predict(mod_G, newdata = dat, type = "response")
pE1 <- predict(mod_E, newdata = dat, type = "response")
# pG1 <- pmin(pmax(pG1, eps), 1 - eps)
# pE1 <- pmin(pmax(pE1, eps), 1 - eps)
# P(G = g_i | C)
pG  <- ifelse(dat$G == 1, pG1, 1 - pG1)
## P(E = e_i | G, C)
pE  <- ifelse(dat$E == 1, pE1, 1 - pE1)
w   <- 1 / (pG * pE)
if (!is.null(truncate_q)) {
q_hi <- quantile(w, truncate_q, na.rm = TRUE)
q_lo <- quantile(w, 1 - truncate_q, na.rm = TRUE)
w    <- pmin(pmax(w, q_lo), q_hi)
}
dat$w <- w
dat
}
sim_dat <- simulate_data_intercept(3000, -1, 2025)
covars_G =  c("X1", "X2", "X5", "X6")
covars_E =  c("X3", "X4", "X5", "X6")
w <- compute_ipw(sim_dat, covars_G = covars_G, covars_E = covars_E, use = "control")
w[w$w > 20,]
sim_dat <- simulate_data_intercept(3000, -6, 2025)
covars_G =  c("X1", "X2", "X5", "X6")
covars_E =  c("X3", "X4", "X5", "X6")
w2 <- compute_ipw(sim_dat, covars_G = covars_G, covars_E = covars_E, use = "control")
w2[w2$w > 20,]
sim_dat <- simulate_data_intercept(3000, -2, 2025)
covars_G =  c("X1", "X2", "X5", "X6")
covars_E =  c("X3", "X4", "X5", "X6")
w3 <- compute_ipw(sim_dat, covars_G = covars_G, covars_E = covars_E, use = "control")
w3[w3$w > 20,]
simulate_data_intercept <- function(n, beta0, seed = NULL) {
if (!is.null(seed)) set.seed(seed)
## ------------------------------------------------------------------
## 1. Generate covariates  X1 … X8   ~  N(0,1), mutually independent
## ------------------------------------------------------------------
X <- matrix(rnorm(n * 8), ncol = 8,
dimnames = list(NULL, paste0("X", 1:8)))
X1 <- X[, 1];  X2 <- X[, 2]        #   X_G  (instrumental for G)
X3 <- X[, 3];  X4 <- X[, 4]        #   X_E  (instrumental for E)
X5 <- X[, 5];  X6 <- X[, 6]        #   X_Y  (outcome-only)
X7 <- X[, 7];  X8 <- X[, 8]        #   C    (common confounders)
## ------------------------------------------------------------------
## 2. Propensity scores for each treatment, given its instruments + C
## ------------------------------------------------------------------
eta_G <-  0.8 * X1 + 0.5 * X2 + 0.3 * X7 + 0.5 * X8      # f(Z_G)
pi_G  <- plogis(eta_G)
eta_E <- -0.5 * X3 + 0.2 * X4 + 0.3 * X7 + 0.5 * X8      # f(Z_E)
pi_E  <- plogis(eta_E)
## ------------------------------------------------------------------
## 3. Joint treatment assignment  (G,E)  ~ Multinomial(1, θ00, θ10, θ01, θ11)
## ------------------------------------------------------------------
p00 <- (1 - pi_G) * (1 - pi_E)
p10 <-  pi_G      * (1 - pi_E)
p01 <- (1 - pi_G) *  pi_E
p11 <-  pi_G      *  pi_E
probs <- cbind(p00, p10, p01, p11)
draw <- apply(probs, 1, function(p) {
sample(1:4, size = 1, prob = p)
})
G <- as.integer(draw %in% c(2, 4))   # (1,0) or (1,1)
E <- as.integer(draw %in% c(3, 4))   # (0,1) or (1,1)
## ------------------------------------------------------------------
## 4. Outcome model  Pr(Y = 1 | Z_Y, G, E)
## ------------------------------------------------------------------
eta_Y <- beta0 +
-0.5 * X5  + 0.4 * X6  - 0.05 * X7 - 0.05 * X8 +   # outcome-only + C
0.3 * G   + 0.4 * E  + 0.8 * (G * E)            # treatments & interaction
pi_Y <- plogis(eta_Y)
Y    <- rbinom(n, size = 1, prob = pi_Y)
## ------------------------------------------------------------------
## 5. Return tidy data frame
## ------------------------------------------------------------------
return(data.frame(Y, G, E, X))
}
############################################################
# 1. Compute the weight w = 1/p(G|C)·1/p(E|G,C)=1/(p(G,E|C))
compute_ipw <- function(dat,
covars_G = paste0("X", 1:6),
covars_E = paste0("X", 1:6),
use = "control",
eps          = 1e-6,
truncate_q   = NULL) {
stopifnot(all(c("Y", "G", "E", covars_G, covars_E) %in% names(dat)))
# Choose the data to fit the model
used_data <- if (use == "control"){
dat[dat$Y == 0, ]
} else if (use == "both") {
dat <- dat
}
# P(G = 1 | C)
f_G   <- reformulate(covars_G, response = "G")
mod_G <- glm(f_G, data = used_data, family = binomial())
# P(E = 1 | G, C)
f_E   <- reformulate(c("G", covars_E), response = "E")
mod_E <- glm(f_E, data = used_data, family = binomial())
pG1 <- predict(mod_G, newdata = dat, type = "response")
pE1 <- predict(mod_E, newdata = dat, type = "response")
# pG1 <- pmin(pmax(pG1, eps), 1 - eps)
# pE1 <- pmin(pmax(pE1, eps), 1 - eps)
# P(G = g_i | C)
pG  <- ifelse(dat$G == 1, pG1, 1 - pG1)
## P(E = e_i | G, C)
pE  <- ifelse(dat$E == 1, pE1, 1 - pE1)
w   <- 1 / (pG * pE)
if (!is.null(truncate_q)) {
q_hi <- quantile(w, truncate_q, na.rm = TRUE)
q_lo <- quantile(w, 1 - truncate_q, na.rm = TRUE)
w    <- pmin(pmax(w, q_lo), q_hi)
}
dat$w <- w
dat
}
sim_dat <- simulate_data_intercept(3000, -1, 2025)
covars_G =  c("X5", "X6", "X7", "X8")
covars_E =  c("X5", "X6", "X7", "X8")
w <- compute_ipw(sim_dat, covars_G = covars_G, covars_E = covars_E, use = "control")
w[w$w > 20,]
sim_dat <- simulate_data_intercept(3000, -6, 2025)
covars_G =  c("X5", "X6", "X7", "X8")
covars_E =  c("X5", "X6", "X7", "X8")
w2 <- compute_ipw(sim_dat, covars_G = covars_G, covars_E = covars_E, use = "control")
w2[w2$w > 20,]
sim_dat <- simulate_data_intercept(3000, -2, 2025)
covars_G =  c("X5", "X6", "X7", "X8")
covars_E =  c("X5", "X6", "X7", "X8")
w3 <- compute_ipw(sim_dat, covars_G = covars_G, covars_E = covars_E, use = "control")
w3[w3$w > 20,]
setwd("/Users/caoyiliu/Desktop/UW/research/7.9/3_weak_confounding2")
source("scripts/data_generation.R")
source("scripts/data_generation.R")
View(simulate_data_intercept)
############################################################
# 1. Compute the weight w = 1/p(G|C)·1/p(E|G,C)=1/(p(G,E|C))
compute_ipw <- function(dat,
covars_G = paste0("X", 1:6),
covars_E = paste0("X", 1:6),
use = "control",
eps          = 1e-6,
truncate_q   = NULL) {
stopifnot(all(c("Y", "G", "E", covars_G, covars_E) %in% names(dat)))
# Choose the data to fit the model
used_data <- if (use == "control"){
dat[dat$Y == 0, ]
} else if (use == "both") {
dat <- dat
}
# P(G = 1 | C)
f_G   <- reformulate(covars_G, response = "G")
mod_G <- glm(f_G, data = used_data, family = binomial())
# P(E = 1 | G, C)
f_E   <- reformulate(c("G", covars_E), response = "E")
mod_E <- glm(f_E, data = used_data, family = binomial())
pG1 <- predict(mod_G, newdata = dat, type = "response")
pE1 <- predict(mod_E, newdata = dat, type = "response")
# pG1 <- pmin(pmax(pG1, eps), 1 - eps)
# pE1 <- pmin(pmax(pE1, eps), 1 - eps)
# P(G = g_i | C)
pG  <- ifelse(dat$G == 1, pG1, 1 - pG1)
## P(E = e_i | G, C)
pE  <- ifelse(dat$E == 1, pE1, 1 - pE1)
w   <- 1 / (pG * pE)
if (!is.null(truncate_q)) {
q_hi <- quantile(w, truncate_q, na.rm = TRUE)
q_lo <- quantile(w, 1 - truncate_q, na.rm = TRUE)
w    <- pmin(pmax(w, q_lo), q_hi)
}
dat$w <- w
dat
}
sim_dat <- simulate_data_intercept(3000, -1, 2025)
covars_G =  c("X5", "X6", "X7", "X8")
covars_E =  c("X5", "X6", "X7", "X8")
w <- compute_ipw(sim_dat, covars_G = covars_G, covars_E = covars_E, use = "control")
w[w$w > 20,]
sim_dat <- simulate_data_intercept(3000, -6, 2025)
covars_G =  c("X5", "X6", "X7", "X8")
covars_E =  c("X5", "X6", "X7", "X8")
w2 <- compute_ipw(sim_dat, covars_G = covars_G, covars_E = covars_E, use = "control")
w2[w2$w > 20,]
sim_dat <- simulate_data_intercept(3000, -2, 2025)
covars_G =  c("X5", "X6", "X7", "X8")
covars_E =  c("X5", "X6", "X7", "X8")
w3 <- compute_ipw(sim_dat, covars_G = covars_G, covars_E = covars_E, use = "control")
w3[w3$w > 20,]
setwd("/Users/caoyiliu/Desktop/UW/research/7.9/2_strong_confounding")
source("scripts/data_generation.R")
############################################################
# 1. Compute the weight w = 1/p(G|C)·1/p(E|G,C)=1/(p(G,E|C))
compute_ipw <- function(dat,
covars_G = paste0("X", 1:6),
covars_E = paste0("X", 1:6),
use = "control",
eps          = 1e-6,
truncate_q   = NULL) {
stopifnot(all(c("Y", "G", "E", covars_G, covars_E) %in% names(dat)))
# Choose the data to fit the model
used_data <- if (use == "control"){
dat[dat$Y == 0, ]
} else if (use == "both") {
dat <- dat
}
# P(G = 1 | C)
f_G   <- reformulate(covars_G, response = "G")
mod_G <- glm(f_G, data = used_data, family = binomial())
# P(E = 1 | G, C)
f_E   <- reformulate(c("G", covars_E), response = "E")
mod_E <- glm(f_E, data = used_data, family = binomial())
pG1 <- predict(mod_G, newdata = dat, type = "response")
pE1 <- predict(mod_E, newdata = dat, type = "response")
# pG1 <- pmin(pmax(pG1, eps), 1 - eps)
# pE1 <- pmin(pmax(pE1, eps), 1 - eps)
# P(G = g_i | C)
pG  <- ifelse(dat$G == 1, pG1, 1 - pG1)
## P(E = e_i | G, C)
pE  <- ifelse(dat$E == 1, pE1, 1 - pE1)
w   <- 1 / (pG * pE)
if (!is.null(truncate_q)) {
q_hi <- quantile(w, truncate_q, na.rm = TRUE)
q_lo <- quantile(w, 1 - truncate_q, na.rm = TRUE)
w    <- pmin(pmax(w, q_lo), q_hi)
}
dat$w <- w
dat
}
sim_dat <- simulate_data_intercept(3000, -1, 2025)
covars_G =  c("X5", "X6", "X7", "X8")
covars_E =  c("X5", "X6", "X7", "X8")
w <- compute_ipw(sim_dat, covars_G = covars_G, covars_E = covars_E, use = "control")
w[w$w > 20,]
sim_dat <- simulate_data_intercept(3000, -6, 2025)
covars_G =  c("X5", "X6", "X7", "X8")
covars_E =  c("X5", "X6", "X7", "X8")
w2 <- compute_ipw(sim_dat, covars_G = covars_G, covars_E = covars_E, use = "control")
w2[w2$w > 20,]
sim_dat <- simulate_data_intercept(3000, -2, 2025)
covars_G =  c("X5", "X6", "X7", "X8")
covars_E =  c("X5", "X6", "X7", "X8")
w3 <- compute_ipw(sim_dat, covars_G = covars_G, covars_E = covars_E, use = "control")
w3[w3$w > 20,]
source("scripts/data_generation.R")
View(simulate_data_intercept)
setwd("/Users/caoyiliu/Desktop/UW/research/7.9/4_very_strong_confounding")
source("scripts/data_generation.R")
View(simulate_data_intercept)
############################################################
# 1. Compute the weight w = 1/p(G|C)·1/p(E|G,C)=1/(p(G,E|C))
compute_ipw <- function(dat,
covars_G = paste0("X", 1:6),
covars_E = paste0("X", 1:6),
use = "control",
eps          = 1e-6,
truncate_q   = NULL) {
stopifnot(all(c("Y", "G", "E", covars_G, covars_E) %in% names(dat)))
# Choose the data to fit the model
used_data <- if (use == "control"){
dat[dat$Y == 0, ]
} else if (use == "both") {
dat <- dat
}
# P(G = 1 | C)
f_G   <- reformulate(covars_G, response = "G")
mod_G <- glm(f_G, data = used_data, family = binomial())
# P(E = 1 | G, C)
f_E   <- reformulate(c("G", covars_E), response = "E")
mod_E <- glm(f_E, data = used_data, family = binomial())
pG1 <- predict(mod_G, newdata = dat, type = "response")
pE1 <- predict(mod_E, newdata = dat, type = "response")
# pG1 <- pmin(pmax(pG1, eps), 1 - eps)
# pE1 <- pmin(pmax(pE1, eps), 1 - eps)
# P(G = g_i | C)
pG  <- ifelse(dat$G == 1, pG1, 1 - pG1)
## P(E = e_i | G, C)
pE  <- ifelse(dat$E == 1, pE1, 1 - pE1)
w   <- 1 / (pG * pE)
if (!is.null(truncate_q)) {
q_hi <- quantile(w, truncate_q, na.rm = TRUE)
q_lo <- quantile(w, 1 - truncate_q, na.rm = TRUE)
w    <- pmin(pmax(w, q_lo), q_hi)
}
dat$w <- w
dat
}
sim_dat <- simulate_data_intercept(3000, -1, 2025)
covars_G =  c("X5", "X6", "X7", "X8")
covars_E =  c("X5", "X6", "X7", "X8")
w <- compute_ipw(sim_dat, covars_G = covars_G, covars_E = covars_E, use = "control")
w[w$w > 20,]
sim_dat <- simulate_data_intercept(3000, -6, 2025)
covars_G =  c("X5", "X6", "X7", "X8")
covars_E =  c("X5", "X6", "X7", "X8")
w2 <- compute_ipw(sim_dat, covars_G = covars_G, covars_E = covars_E, use = "control")
w2[w2$w > 20,]
sim_dat <- simulate_data_intercept(3000, -2, 2025)
covars_G =  c("X5", "X6", "X7", "X8")
covars_E =  c("X5", "X6", "X7", "X8")
w3 <- compute_ipw(sim_dat, covars_G = covars_G, covars_E = covars_E, use = "control")
w3[w3$w > 20,]
setwd("/Users/caoyiliu/Desktop/UW/research/7.18/0_original")
w <- c(1, 2)
?pmin
cutoff <- 0.2
w <- pmin(w, cutoff)
w
